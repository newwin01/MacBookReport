## Compiler: Scanner and Parser

컴파일러는 소스 코드를 기계어로 번역하는 프로그램으로, 이 과정에서 여러 단계를 거칩니다. 그 중에서도 스캐너(Scanner)와 파서(Parser)는 초기 단계에서 중요한 역할을 합니다.
스캐너는 어휘 분석기(Lexical Analyzer)라고도 불리며, 컴파일러의 첫 번째 단계에서 작동합니다. 스캐너의 주요 역할은 소스 코드의 문자열을 읽어들이고, 이를 토큰(Token)이라는 기본 단위로 분할하는 것입니다.

스캐너는 소스 코드에서 의미 있는 최소 단위인 토큰을 인식합니다. 토큰은 키워드, 식별자, 연산자, 리터럴, 구분자 등으로 이루어집니다. 예를 들어, C언어의 int x = 10;라는 코드에서 int, x, =, 10, ;는 각각 하나의 토큰입니다. 토큰화 과정에서 코드 내의 공백 문자, 탭, 줄바꿈, 주석 등은 의미가 없으므로 무시됩니다. 잘못된 토큰을 인식하면 오류를 보고합니다. 예를 들어, 식별자 이름에 허용되지 않는 문자가 포함된 경우 오류가 발생합니다.
스캐너의 결과는 토큰의 리스트로, 이 리스트는 다음 단계인 파서로 전달됩니다.

파서는 구문 분석기(Syntax Analyzer)라고도 불리며, 스캐너가 생성한 토큰 리스트를 입력으로 받아 소스 코드의 문법 구조를 분석합니다. 파서는 주어진 토큰들이 언어의 문법 규칙(Syntax Rules)에 맞는지 확인합니다. 이를 위해 파서는 주로 BNF(Backus-Naur Form)나 EBNF(Extended Backus-Naur Form) 같은 형식으로 정의된 문법을 사용합니다. 문법에 맞다면 토큰들로부터 파스 트리(Parse Tree) 또는 추상 구문 트리(Abstract Syntax Tree, AST)를 생성합니다. 파스 트리는 소스 코드의 문법 구조를 계층적으로 표현한 트리 구조입니다. 파서는 문법에 맞지 않는 토큰의 조합을 발견하면 오류를 보고합니다. 예를 들어, int = x 10;는 잘못된 구문으로 인식되어 오류가 발생합니다.

스캐너와 파서가 함께 작동하여 소스 코드가 올바르게 작성되었는지 확인하고, 컴파일러의 후속 단계(중간 코드 생성, 최적화, 코드 생성 등)로 넘길 수 있는 구조화된 표현을 제공합니다. 이처럼 스캐너와 파서는 컴파일러의 초기 단계에서 소스 코드의 의미를 해석하고 오류를 발견하는 데 중요한 역할을 합니다.


LR Parser

[LRParser](../Compiler/LRParser/)

LR 파서는 왼쪽에서 오른쪽으로 입력을 읽고, 가장 오른쪽에 있는 유도 과정(Rightmost Derivation)을 역으로 수행하는 파서입니다. 이 파서는 보통 하향식 구문 분석기에 비해 더 강력하고 복잡한 문법을 처리할 수 있습니다. LR 파서의 주요 특징은 다음과 같습니다:

    L (Left to right): 입력을 왼쪽에서 오른쪽으로 읽습니다.
    R (Rightmost derivation in reverse): 오른쪽 끝에서부터 유도 과정을 역순으로 수행합니다.
    구조: 주로 스택을 사용하여 상태를 관리하고, 상태 전환을 통해 구문 분석을 수행합니다.
    유형: LR 파서는 SLR(간단한 LR), LALR(룩어헤드 LR), Canonical LR(정규 LR) 등 여러 변종이 있습니다.
    장점: 매우 복잡한 문법도 처리할 수 있습니다.
    단점: 구현이 복잡하며, 컴파일 시간과 메모리 사용량이 많을 수 있습니다.

LL Parser

[LLParser](../Compiler/LLParser/)

LL 파서는 왼쪽에서 오른쪽으로 입력을 읽고, 가장 왼쪽에 있는 유도 과정(Leftmost Derivation)을 수행하는 파서입니다. LL 파서는 상대적으로 단순한 문법을 처리하는 데 적합하며, 재귀 하향 파서의 기초가 됩니다. LL 파서의 주요 특징은 다음과 같습니다:

    L (Left to right): 입력을 왼쪽에서 오른쪽으로 읽습니다.
    L (Leftmost derivation): 왼쪽 끝에서부터 유도 과정을 수행합니다.
    구조: 주로 재귀 호출을 통해 구문 분석을 수행합니다.
    유형: LL(1) 파서, LL(k) 파서 등으로 구분됩니다. 여기서 'k'는 미리 보기를 할 토큰의 수를 의미합니다.
    장점: 구현이 비교적 간단하고 이해하기 쉽습니다.
    단점: 더 복잡한 문법을 처리하는 데 한계가 있습니다.

Recursive Descent Parser

[Recursive Descent Parser](../Compiler/RecursiveParser/)

재귀 하향 파서(Recursive Descent Parser)는 LL 파서의 일종으로, 각 문법 규칙을 하나의 재귀 함수로 표현합니다. 입력을 재귀적으로 처리하여 구문 분석을 수행합니다. 재귀 하향 파서의 주요 특징은 다음과 같습니다:

    구조: 각 문법 규칙에 대해 하나의 재귀 함수를 사용하여 구문 분석을 수행합니다.
    구현: 매우 직관적이며, 문법 규칙을 함수로 쉽게 매핑할 수 있습니다.
    미리 보기: 일반적으로 LL(1) 문법을 처리할 수 있지만, 백트래킹이나 LL(k)을 사용하여 더 복잡한 문법을 처리할 수 있습니다.
    장점: 이해하기 쉽고, 작은 언어나 DSL(도메인 특화 언어)에서 매우 효과적입니다.
    단점: 좌측 재귀가 있는 문법을 처리할 수 없으며, 백트래킹이 필요한 경우 성능이 저하될 수 있습니다.

이 세 가지 파서는 각각의 장단점이 있으며, 특정 문법과 요구사항에 따라 적합한 파서가 선택됩니다. LR 파서는 더 복잡하고 강력한 문법을 처리할 수 있는 반면, LL 파서와 재귀 하향 파서는 구현이 더 간단하고 직관적입니다.